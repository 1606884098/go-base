package main

import "fmt"

/*
数组：是指一系列同一类型数据的集合,数组是一个由固定长度的特定类型元素组成的序列
，一个数组可以由零个或多个元素组成。
*/
func main() {
	/*
		var 数组变量名 [元素数量]Type
		数组变量名：数组声明及使用时的变量名。
		元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整
			     型数值，元素数量不能含有到运行时才能确认大小的数值。
		Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。

		数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减
		1 的位置，内置函数 len() 可以返回数组中元素的个数。

		默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就
		是 0，同时也可以使用数组字面值语法

		在数组的定义中，如果在数组长度的位置出现“...”省略号，则表示数组的长度是根据初
		始化值的个数来计算


		1) 数组的地址可以通过数组名来获取 &intArr
		2) 数组的第一个元素的地址，就是数组的首地址
		3) 数组的各个元素的地址间隔是依据数组的类型决定
	*/
	p := new([10]int) //得到的是指针，方便传值
	fmt.Println(p)
	var intArray [3]int = [3]int{1, 2, 3} //var intArray []int 是切片
	//a:=[3]int{1,2,3}
	//d:=[5]int{2:10,4:9}指定下标来赋值  下标：值
	//b:=[...]int{1,2,3}//通过赋值来确定个数
	/*
		数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型
		，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定
		q := [3]int{1, 2, 3}
		q = [4]int{1, 2, 3, 4} // 编译错误：无法将 [4]int 赋给 [3]int
		比较两个数组是否相等
		如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通
		过较运算符（==和!=）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时
		候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。
	*/
	a := [2]int{1, 2}
	b := [...]int{1, 2}
	c := [2]int{1, 3}
	fmt.Println(a == b, a == c, b == c) // "true false false"
	//d := [3]int{1, 2}
	//fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int

	for i := 0; i < len(intArray); i++ { //普通遍历
		//从打印出来的地址可以看出是连续的地址空间，空间的大小跟类型有关
		fmt.Printf("index=%d,val=%d,address=%x\n", i, intArray[i], &intArray[i])
		/*		index=0,val=1,address=c0000a0120
				index=1,val=2,address=c0000a0128
				index=2,val=3,address=c0000a0130*/
	}

	for i, v := range intArray {
		fmt.Printf("index=%d,val=%d\n", i, v)
	}

	/*
		Go 中数组赋值和函数传参都是值复制的。假想每次传参都用数组，那么每次数组都要被复
		制一遍。如果数组大小有 100万，在64位机器上就需要花费大约 800W 字节，即 8MB 内
		存。这样会消耗掉大量的内存。于是乎有人想到，函数传参用数组的指针。
		func main() {
		    arrayA := [2]int{100, 200}
		    testArrayPoint(&arrayA)   // 1.传数组指针
		    arrayB := arrayA[:]
		    testArrayPoint(&arrayB)   // 2.传切片
		    fmt.Printf("arrayA : %p , %v\n", &arrayA, arrayA)
		}
		func testArrayPoint(x *[]int) {
		    fmt.Printf("func Array : %p , %v\n", x, *x)
		    (*x)[1] += 100
		}
		打印结果：
		    func Array : 0xc4200b0140 , [100 200]
		    func Array : 0xc4200b0180 , [100 300]
		    arrayA : 0xc4200b0140 , [100 400]
		这也就证明了数组指针确实到达了我们想要的效果。现在就算是传入10亿的数组，也只需要
		再栈上分配一个8个字节的内存给指针就可以了。这样更加高效的利用内存，性能也比之前的
		好.不过传指针会有一个弊端，从打印结果可以看到，第一行和第三行指针地址都是同一个，
		万一原数组的指针指向更改了，那么函数里面的指针指向都会跟着更改。
	*/
}
