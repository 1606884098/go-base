package main

import (
	"fmt"
	"strconv"
)

func main() {
	/*
			原码、反码和补码
			计算机底层是通过二进制表示数字的，我们把这种二进制形式的数字称之为机器数，数字是
			有正负之分的，这个正负是通过机器数的第一位作为标识的（俗称符号位）：0 表示正数，
			1 表示负数。为区别有符号数真实值与形式值的不同，又将带符号位的机器数对应的真正数
			值称为机器数的真值（无符号数的真值就是自身）。
			除了基本的二进制数字外，计算机还提供了三种数字编码方式：原码、反码和补码。
			原码就是符号位+真值，比如：
			[+1]原 = 0000 0001
			[-1]原 = 1000 0001
			以 8 位二进制数表示范围为例，使用原码的话对应的区间范围是 [11111111, 01111111]
			，即 [-127, 127]。
			我们接着来看反码，正数的反码是自身，负数的反码是在其原码基础上，符号位不变，其余各
			位按位取反。比如：
			[+1]反 = 0000 0001
			[-1]反 = 1111 1110
			以 8 位二进制数表示范围为例，使用反码的话对应的区间范围是 [11111111, 01111111]
			，还是 [-127, 127]。
			上面两种编码都存在一个问题，那就是数字 0 存在 +0 和 -0 两种编码：
			[+0]原 = 0000 0000
			[-0]原 = 1000 0000
			[+0]反 = 0000 0000
			[-0]反 = 1111 1111
			这就导致数字 0 在计算机中的编码不唯一，对于凡事要求确定性的计算机来说，这是绝对不
			行的，为了解决这个问题，计算机科学家们又提出补码的概念。
			正数的补码和反码一样，都是其自身，而负数的补码是在其原码基础上，符号位不变，其余各
			位按位取反，最后+1（即反码+1）。比如：
			[+1]补 = 0000 0001
			[-1]补 = 1111 1111
			就是这个简单的 +1，却非常巧妙地解决了数字 0 双重编码的问题，现在，+0 的补码是
			0000 0000，但是 -0 的补码变成了 1000 0001，所以只有一个表示 0 的编码了。
			不仅如此，所有的负数都整体做了 +1 操作，之前的 1111 1111 由于进位溢出，变成了
			1000 0000，我们将这个数字用于表示 -128，所以对于 8 位机器数，通过补码表示的话，
			现在的情况是：
			• 正数区间依然是 [0, 127] 不变；
			• 负数区间变成了 [-128, -1]（之前 [-127, -0] 每个数字 +1 演化而来）。
			这也是目前计算机系统底层 8 位整型数字的区间范围，所以计算机底层是通过补码来表示数
			字的，也只能通过补码来表示。
			了解到这里，我们再来看为什么 uint 类型的 255 转化为 int8 类型的值后是 -1。
			255 是无符号正数，补码和原码都是 255，即 16 个 1 组成的机器数，转化为 int8 类型
			后，由于 int8 只能存放 8 位机器数，所以会截取 255 后 8 位数字，也就是 1111 1111
			，int8 是有符号数字，第一位是符号位，所以真值是后 7 位，计算机底层通过补码表示数
			字，需要将其转化为补码，而这个数字又是负数，所以需要将后 7 位按位取反再 +1，也就
			是 1000 0001，即 -1。
			1000 0001
			1111 1110
			1111 1111 -1

			有符号和无符号的区别：
			有符号数是可以用来区分数值的正负。而无符号数仅有正值，没有负值。其次当一个数是无符号
			数时，它的最高位仅用来表示该数的大小。而当一个数是有符号数时，此时的最高位称为符号位。
			该符号位为1时表示该数为负值，为0时则表示为正值。最后有符号数和无符号数两者表示的范围
			不同，即同样长度的字节，有符号数比无符号数的最大值出现缩水。
			1.1. 内置类型
			1.1.1. 值类型：
			类型	名称	长度 零值	说明
			bool	布尔类型	1	false	其值不为真即为假，不可以用数字代表true或false
			byte	字节型	1	0	uint8别名
			int, uint 整型	-	0	有符号32位或无符号64位
			int8	整型	1	0	-128 ~ 127,
			uint8	整型	1	0	0 ~ 255
			int16 	整型	2	0	-32768 ~ 32767,
			uint16	整型	2	0	0 ~ 65535
			int32	整型	4	0	-2147483648 到 2147483647
			uint32	整型	4	0	0 到 4294967295(42亿)
			int64 	整型	8	0	-9223372036854775808到 92233720368547758070
			uint64	整型	8	0	到 18446744073709551615(1844京)
			float32	浮点型	4	0.0	小数位精确到7位
			float64	浮点型	8	0.0	小数位精确到15位
			string	字符串	 	""	utf-8字符串
			complex64
			complex128
			rune，占用4个字节，共32位比特位，所以它和 uint32 本质上也没有区别。
			uintptr	4或8	    以存储指针的 uint32 或 uint64 整数
		    array    -- 固定长度的数组（值类型）
			struct	 	 	    值类型

			slice	 		nil	引用类型(指针类型)
			map	 	    	nil	引用类型(映射)
			channel	 		nil	引用类型(管道)
			interface	 	nil	接口
			function	 	nil	函数
	*/
	var a bool = true //布尔类型:长度1字节，其值不为真即为假，不可以用数字代表true或false
	fmt.Print(a)
	var ()
	/*
		不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，
		例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们
		需要直接获得编译器的支持。
		   append          -- 用来追加元素到数组、slice中,返回修改后的数组、slice
		   close           -- 主要用来关闭channel
		   delete          -- 从map中删除key对应的value
		   panic            -- 停止常规的goroutine  （panic和recover：用来做错误处理）
		   recover         -- 允许程序定义goroutine的panic动作
		   real            -- 返回complex的实部   （complex、real imag：用于创建和操作复数）
		   imag            -- 返回complex的虚部
		   make            -- 用来分配内存，返回Type本身(只能应用于slice, map, channel)
		   new                -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针
		   cap                -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）
		   copy            -- 用于复制和连接slice，返回复制的数目
		   len                -- 来求长度，比如string、array、slice、map、channel ，返回长度
		   print、println     -- 底层打印函数，在部署环境中建议使用 fmt 包

		内置接口error
		type error interface { //只要实现了Error()函数，返回值为String的都实现了err接口
			Error()    String
		}
	*/
	/*
		数值类型之间的转化
		整型之间的转化
		关于数值类型之间的转化，我们前面在介绍运算符的时候已经提到过，在进行类型转化时只需
		要调用要转化的数据类型对应的函数即可：
	*/

	v1 := uint(16)   // 初始化 v1 类型为 unit
	v2 := int8(v1)   // 将 v1 转化为 int8 类型并赋值给 v2
	v3 := uint16(v2) // 将 v2 转化为 uint16 类型并赋值给 v3
	/*看起来很简单，不过需要注意，在有符号与无符号以及高位数字向低位数字转化时，需要
	注意数字的溢出和截断。
	比如我们看这个例子：*/
	v4 := uint(-255)
	/*由于 uint 是无符号整型，无符号数字不包含负数，所以上述转化编译时会报溢出错误：
	constant -255 overflows uint
	我们将上述代码改造如下，将无符号数字转化为有符号数字：*/
	v5 := uint(255)
	v6 := int8(v5) // v2 = -1
	fmt.Print(v3, v4, v6)
	/*由于 int8 能够表示的范围是 -128~127，255 超出其表示范围，所以，会截取后8位，
	v1 是一个无符号整型，后八位都是 1，int8 是一个有符号的整型，所以最高位作为符号位
	，因此转化后的数字 v2 是负数，取 1111 1111 的补码，所以转化结果是 -1。
	有人可能困惑为啥是 -1，而不是 -127，这就要了解计算机底层是如何表示数字的了。
	*/

	/*整型与浮点型之间的转化
	然后，我们再来看下整型和浮点型之间的转化，浮点型转化为整型时，小数位被丢弃：
	*/
	v100 := 99.99
	v200 := int(v100) // v2 = 99
	/*将整型转化为浮点型时，比较简单，直接调用对应的函数即可：
	 */
	v111 := 99
	v222 := float64(v111) // v2 = 99
	/*数值和布尔类型之间的转化
	目前 Go 语言不支持将数值类型转化为布尔型，你需要自己根据需求去实现类似的转化。
	字符串和其他基本类型之间的转化
	将整型转化为字符串
	整型数据可以通过 Unicode 字符集转化为对应的 UTF-8 编码的字符串：
	*/
	v1111 := 65
	v2222 := string(v1111) // v2 = A
	v33333 := 30028
	v4444 := string(v33333) // v4 = 界
	/*Unicode 兼容 ASCII 字符集，所以 65 被转化为 A。
	此外，还可以将 byte 数组或者 rune 数组转化为字符串，因为字符串底层就是通过这两
	个基本字符类型构建的：
	*/
	v123 := []byte{'h', 'e', 'l', 'l', 'o'}
	v212 := string(v123) // v2 = hello
	v312 := []rune{0x5b66, 0x9662, 0x541b}
	v411 := string(v312) // v4 = 清华尹成大神
	fmt.Print(v200, v222, v2222, v4444, v212, v411)
	/*当然了，byte 是 uint8 的别名，rune 是 uint32 的别名，所以也可以看做是整型数
	组和字符串之间的转化。
	*/
	/*strconv 包
	Go 语言默认不支持将字符串类型强制转化为数值类型，即使字符串中包含数字也不行。
	如果要实现更强大的基本数据类型与字符串之间的转化，可以使用 Go 官方 strconv
	包提供的函数：
	*/
	v1q := "100"
	v2q, _ := strconv.Atoi(v1q) // 将字符串转化为整型，v2 = 100
	v3q := 100
	v4q := strconv.Itoa(v3q) // 将整型转化为字符串, v4 = "100"
	v5q := "true"
	v6q, _ := strconv.ParseBool(v5q) // 将字符串转化为布尔型
	v5q = strconv.FormatBool(v6q)    // 将布尔值转化为字符串
	v7 := "100"
	v8, _ := strconv.ParseInt(v7, 10, 64)  // 将字符串转化为整型，第二个参数表示进制，第三个参数表示最大位数
	v7 = strconv.FormatInt(v8, 10)         // 将整型转化为字符串，第二个参数表示进制
	v9, _ := strconv.ParseUint(v7, 10, 64) // 将字符串转化为无符号整型，参数含义同 ParseInt
	v7 = strconv.FormatUint(v9, 10)        // 将字符串转化为无符号整型，参数含义同 FormatInt
	v10 := "99.99"
	v11, _ := strconv.ParseFloat(v10, 64) // 将字符串转化为浮点型，第二个参数表示精度
	v10 = strconv.FormatFloat(v11, 'E', -1, 64)
	q := strconv.Quote("Hello, 世界")       // 为字符串加引号
	q = strconv.QuoteToASCII("Hello, 世界") // 将字符串转化为 ASCII 编码
	fmt.Print(v2q, v4q, q)
}
